services:
  postgres:
    container_name: postgres
    image: postgres:17
    networks:
      - teranode-network
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: really_strong_password_change_me
      POSTGRES_DB: postgres
      PGDATA: /var/lib/postgresql/data
    ports:
      - "127.0.0.1:5432:5432"
    volumes:
      - ${DATA_PATH}/postgres:/var/lib/postgresql/data
    entrypoint: [ "/bin/bash", "-c" ]
    command: |
      "
      cat > /docker-entrypoint-initdb.d/init.sql <<'EOF'
      CREATE ROLE teranode LOGIN
        PASSWORD 'teranode'
        SUPERUSER INHERIT NOCREATEDB NOCREATEROLE NOREPLICATION;
      GRANT teranode TO postgres;
      CREATE DATABASE teranode
        WITH OWNER = teranode
        ENCODING = 'UTF8'
        CONNECTION LIMIT = -1;
      EOF
      cat > /refresh-collation.sh <<'EOF'
      #!/bin/bash
      set -e
      # Wait for postgres to be ready
      until pg_isready -U postgres > /dev/null 2>&1; do
        sleep 1
      done
      # Refresh collation version to prevent warnings/errors after postgres image updates
      # When postgres updates to a newer glibc version, the collation version changes
      # and existing databases need to be refreshed to avoid index corruption
      psql -U postgres -d postgres -c 'ALTER DATABASE postgres REFRESH COLLATION VERSION;' 2>/dev/null || true
      psql -U postgres -d teranode -c 'ALTER DATABASE teranode REFRESH COLLATION VERSION;' 2>/dev/null || true
      EOF
      chmod +x /refresh-collation.sh
      # Run collation refresh in background after postgres starts
      /refresh-collation.sh &
      exec /usr/local/bin/docker-entrypoint.sh postgres
      "
    restart: on-failure
    healthcheck:
      test: [ "CMD-SHELL", "pg_isready -U postgres" ]
      interval: 5s
      timeout: 5s
      retries: 5

  kafka-shared:
    container_name: kafka-shared
    image: redpandadata/redpanda:latest
    mem_limit: 1024m
    restart: on-failure
    networks:
      - teranode-network
    command:
      - redpanda start
      - --smp 1
      - --overprovisioned
      - --node-id 0
      - --kafka-addr PLAINTEXT://0.0.0.0:9092
      - --advertise-kafka-addr PLAINTEXT://kafka-shared:9092
      - --pandaproxy-addr 0.0.0.0:9093
      - --advertise-pandaproxy-addr localhost:9093
    ports:
      - "127.0.0.1:8081:8081"
      - "127.0.0.1:9092:9092"
      - "127.0.0.1:9093:9093"

  kafka-console-shared:
    container_name: kafka-console-shared
    image: docker.redpanda.com/redpandadata/console:v3.2.2
    networks:
      - teranode-network
    restart: on-failure
    environment:
      CONFIG_FILEPATH: /etc/console/config.yml
    volumes:
      - ../../../errors/error.proto:/etc/protos/errors/error.proto:ro
      - ../../../util/kafka/kafka_message/kafka_messages.proto:/etc/protos/kafka_messages.proto:ro
      - ../../../model/model.proto:/etc/protos/model.proto:ro
      - ../../../services/propagation/propagation_api/propagation_api.proto:/etc/protos/propagation_api.proto:ro
      - ../base/kafka-console-config.yml:/etc/console/config.yml:ro
    ports:
      - "127.0.0.1:8080:8080"
    depends_on:
      - kafka-shared

  # Primary Aerospike node (maintains original name for compatibility)
  aerospike:
    container_name: aerospike
    image: aerospike/aerospike-server:8.1
    command: --config-file /etc/aerospike.conf
    networks:
      - teranode-network
    ports:
      - "127.0.0.1:3000:3000"
    restart: on-failure
    volumes:
      - ./aerospike.conf:/etc/aerospike.conf
      - ${DATA_PATH}/aerospike/data:/opt/aerospike/data
      - ${DATA_PATH}/aerospike/smd:/opt/aerospike/smd
    privileged: true  # Allow the container to access raw devices
    hostname: aerospike

  # Optional second Aerospike node
  aerospike-2:
    container_name: aerospike-2
    image: aerospike/aerospike-server:8.1
    command: --config-file /etc/aerospike.conf
    networks:
      - teranode-network
    ports:
      - "127.0.0.1:3010:3000" # Map to different host port to avoid conflicts
    restart: on-failure
    volumes:
      - ./aerospike.conf:/etc/aerospike.conf
      - ${DATA_PATH}/aerospike-2/data:/opt/aerospike/data
      - ${DATA_PATH}/aerospike-2/smd:/opt/aerospike/smd
    privileged: true
    hostname: aerospike-2

  # Optional third Aerospike node, replication factor still set to 2
  aerospike-3:
    container_name: aerospike-3
    image: aerospike/aerospike-server:8.1
    command: --config-file /etc/aerospike.conf
    networks:
      - teranode-network
    ports:
      - "127.0.0.1:3020:3000" # Map to different host port to avoid conflicts
    restart: on-failure
    volumes:
      - ./aerospike.conf:/etc/aerospike.conf
      - ${DATA_PATH}/aerospike-3/data:/opt/aerospike/data
      - ${DATA_PATH}/aerospike-3/smd:/opt/aerospike/smd
    privileged: true
    hostname: aerospike-3

  # Aerospike Enterprise Edition, single node in evaluation mode
  aerospike-ee:
    container_name: aerospike
    image: aerospike/aerospike-server-enterprise:8.1
    networks:
      - teranode-network
    ports:
      - "127.0.0.1:3000:3000"
    restart: unless-stopped
    stop_grace_period: 600s # to allow ASMT to backup the indexes for warm restarts
    volumes:
      - ./aerospike-ee.conf:/etc/aerospike.conf
      - ./aerospike-asmt-wrapper.sh:/aerospike-asmt-wrapper.sh:ro
      - ${DATA_PATH}/aerospike/data:/opt/aerospike/data
      - ${DATA_PATH}/aerospike/smd:/opt/aerospike/smd
      - ${DATA_PATH}/aerospike/asmt:/backup/indexes
    entrypoint: ["/bin/bash", "/aerospike-asmt-wrapper.sh"]
    privileged: true  # Allow the container to access raw devices
    hostname: aerospike

  aerospike-exporter:
    image: aerospike/aerospike-prometheus-exporter:latest
    container_name: aerospike-exporter
    environment:
      AS_HOST: aerospike
      AS_PORT: 3000
      AGENT_BIND_PORT: 10145
      METRIC_LABELS: "type='development',source='aerospike'"
    networks:
      - teranode-network

  prometheus:
    container_name: prometheus
    image: prom/prometheus:v2.44.0
    ports:
      - "127.0.0.1:9090:9090"
    networks:
      - teranode-network
    user: "0:0"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
      - ${DATA_PATH}/prometheus:/prometheus

  grafana:
    container_name: grafana
    image: grafana/grafana:latest
    ports:
      - "127.0.0.1:3005:3000"
    networks:
      - teranode-network
    user: "0:0"
    volumes:
      - ./grafana_datasource.yaml:/etc/grafana/provisioning/datasources/main.yaml
      - ./grafana_dashboards/main.yaml:/etc/grafana/provisioning/dashboards/main.yaml
      - ./grafana_dashboards:/var/lib/grafana/dashboards
      - ${DATA_PATH}/grafana/grafana.db:/var/lib/grafana
    depends_on:
      - prometheus

  asset-cache:
    container_name: asset-cache
    image: nginx:1.27.4
    networks:
      - teranode-network
    ports:
      - "127.0.0.1:8000:8000"
    depends_on:
      - asset
    volumes:
      - ./asset-cache-nginx.conf:/etc/nginx/nginx.conf:ro
      - ${DATA_PATH}/nginx:/tmp/nginx
    restart: on-failure
    healthcheck:
      test: ["CMD", "nginx", "-t"]
      interval: 5s
      timeout: 5s
      retries: 5
